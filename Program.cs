// Please note that almost the entirety of this code was generated by Claude 3.7 Sonnet and Gemini 2.0 Flash.

using System;
using System.IO;
using System.Threading;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;

namespace TerminalImageViewer
{
    class Program
    {
        static int viewportX = 0;
        static int viewportY = 0;
        static double zoom = 1.0;
        static bool running = true;
        static Pixel[,] image;
        static int imgHeight;
        static int imgWidth;

        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("Usage: termie <image_path>");
                return;
            }

            string imagePath = args[0];
            if (!File.Exists(imagePath))
            {
                Console.WriteLine($"Error: File '{imagePath}' not found.");
                return;
            }

            image = LoadImage(imagePath);
            if (image == null)
            {
                Console.WriteLine("Failed to load image.");
                return;
            }

            imgHeight = image.GetLength(0);
            imgWidth = image.GetLength(1);

            viewportX = imgWidth / 2;
            viewportY = imgHeight / 2;

            Console.Clear();
            Console.CursorVisible = false;

            RenderImage();

            while (running)
            {
                HandleInput();
            }

            Console.CursorVisible = true;
            Console.Clear();
        }

        static Pixel[,] LoadImage(string path)
        {
            try
            {
                string extension = Path.GetExtension(path).ToLower();

                if (extension == ".ppm")
                {
                    return LoadPPM(path);
                }
                else
                {
                    return LoadWithImageSharp(path);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading image: {ex.Message}");
                return null;
            }
        }

        static Pixel[,] LoadWithImageSharp(string path)
        {
            try
            {
                using (var image = Image.Load<Rgba32>(path))
                {
                    int width = image.Width;
                    int height = image.Height;
                    Pixel[,] result = new Pixel[height, width];

                    // Process image in memory to avoid file locking issues
                    image.ProcessPixelRows(accessor =>
                    {
                        for (int y = 0; y < height; y++)
                        {
                            Span<Rgba32> pixelRow = accessor.GetRowSpan(y);

                            for (int x = 0; x < width; x++)
                            {
                                Rgba32 pixel = pixelRow[x];

                                if (pixel.A < 255)
                                {
                                    // Handle transparency by blending with white background
                                    float alpha = pixel.A / 255f;
                                    byte r = (byte)(pixel.R * alpha + 255 * (1 - alpha));
                                    byte g = (byte)(pixel.G * alpha + 255 * (1 - alpha));
                                    byte b = (byte)(pixel.B * alpha + 255 * (1 - alpha));
                                    result[y, x] = new Pixel(r, g, b);
                                }
                                else
                                {
                                    result[y, x] = new Pixel(pixel.R, pixel.G, pixel.B);
                                }
                            }
                        }
                    });

                    return result;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing image: {ex.Message}");
                return null;
            }
        }

        static Pixel[,] LoadPPM(string path)
        {
            byte[] fileData = File.ReadAllBytes(path);

            if (fileData.Length > 3 && fileData[0] == 'P' && fileData[1] == '6')
            {
                int index = 2;
                while (fileData[index] != '\n' && fileData[index] != ' ') index++;

                while (fileData[index] == ' ' || fileData[index] == '\n' || fileData[index] == '#')
                {
                    if (fileData[index] == '#')
                    {
                        while (fileData[index] != '\n') index++;
                    }
                    index++;
                }

                int width = 0;
                while (fileData[index] >= '0' && fileData[index] <= '9')
                {
                    width = width * 10 + (fileData[index] - '0');
                    index++;
                }

                while (fileData[index] == ' ' || fileData[index] == '\n') index++;

                int height = 0;
                while (fileData[index] >= '0' && fileData[index] <= '9')
                {
                    height = height * 10 + (fileData[index] - '0');
                    index++;
                }

                while (fileData[index] == ' ' || fileData[index] == '\n') index++;

                while (fileData[index] >= '0' && fileData[index] <= '9') index++;
                index++;

                Pixel[,] image = new Pixel[height, width];

                for (int y = 0; y < height; y++)
                {
                    for (int x = 0; x < width; x++)
                    {
                        if (index + 2 < fileData.Length)
                        {
                            byte r = fileData[index++];
                            byte g = fileData[index++];
                            byte b = fileData[index++];
                            image[y, x] = new Pixel(r, g, b);
                        }
                    }
                }

                return image;
            }

            Console.WriteLine("Invalid PPM format. Only P6 is supported.");
            return null;
        }

        static string previousFrame = "";

        static void RenderImage()
        {
            int termWidth = Console.WindowWidth;
            int termHeight = Console.WindowHeight - 1;

            System.Text.StringBuilder buffer = new System.Text.StringBuilder(termWidth * termHeight * 20);

            double scaleWidth = (double)termWidth / imgWidth;
            double scaleHeight = (double)termHeight / imgHeight;
            double baseScale = Math.Min(scaleWidth, scaleHeight);
            double finalScale = baseScale * zoom;

            int visibleWidth = (int)(termWidth / finalScale);
            int visibleHeight = (int)(termHeight / finalScale);

            int startX = viewportX - visibleWidth / 2;
            int startY = viewportY - visibleHeight / 2;

            buffer.Append("\x1b[H");

            for (int y = 0; y < termHeight; y++)
            {
                for (int x = 0; x < termWidth; x++)
                {
                    int imgX = (int)(x / finalScale) + startX;
                    int imgY = (int)(y / finalScale) + startY;

                    if (imgX >= 0 && imgX < imgWidth && imgY >= 0 && imgY < imgHeight)
                    {
                        Pixel pixel = image[imgY, imgX];
                        buffer.Append($"\x1b[48;2;{pixel.R};{pixel.G};{pixel.B}m \x1b[0m");
                    }
                    else
                    {
                        buffer.Append(" ");
                    }
                }
                if (y < termHeight - 1)
                    buffer.Append("\n");
            }

            string statusLine = $"{zoom:F2}x | {viewportX},{viewportY}   ";

            buffer.Append("\x1b[K").Append(statusLine);

            string currentFrame = buffer.ToString();

            if (string.IsNullOrEmpty(previousFrame))
            {
                Console.Clear();
                Console.CursorVisible = false;
            }

            Console.Write(currentFrame);
            previousFrame = currentFrame;
        }

        static void HandleInput()
        {
            ConsoleKeyInfo key = Console.ReadKey(true);
            int moveAmount = 10;
            int repeat = char.IsUpper(key.KeyChar) ? 5 : 1;
            for (int i = 0; i < repeat; i++)
            {
                switch (key.KeyChar.ToString().ToLower())
                {
                    case "q":
                        running = false;
                        break;
                    case "h":
                        viewportX = Math.Max(0, viewportX - moveAmount);
                        break;
                    case "j":
                        viewportY = Math.Min(imgHeight - 1, viewportY + moveAmount);
                        break;
                    case "k":
                        viewportY = Math.Max(0, viewportY - moveAmount);
                        break;
                    case "l":
                        viewportX = Math.Min(imgWidth - 1, viewportX + moveAmount);
                        break;
                    case "w":
                        zoom *= 1.2;
                        break;
                    case "s":
                        zoom = Math.Max(0.01, zoom / 1.2);
                        break;
                }
            }
            RenderImage();
        }
    }

    struct Pixel
    {
        public byte R, G, B;

        public Pixel(byte r, byte g, byte b)
        {
            R = r;
            G = g;
            B = b;
        }
    }
}
